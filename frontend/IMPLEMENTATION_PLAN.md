# Frontend Implementation Plan - Assistant UI

## Overview

This frontend will use **[assistant-ui](https://github.com/assistant-ui/assistant-ui)**, a production-grade React/TypeScript library for building AI chat interfaces. It's designed for rapid development with deep customization capabilities and supports integration with custom backends.

### Why assistant-ui?

- **Backend Agnostic**: Easily integrates with custom backend frameworks via ExternalStoreRuntime
- **Production Ready**: Handles streaming, auto-scrolling, accessibility out of the box
- **Composable Components**: Fully customizable UI primitives
- **TypeScript Native**: Strong typing throughout
- **Y Combinator Backed**: 200k+ monthly downloads, actively maintained
- **JWT Compatible**: Full control over API requests for authentication

---

## Key Features

### 1. **Streaming Support**
- Real-time message streaming from backend agents
- Progressive UI updates as messages arrive
- Built-in cancellation support

### 2. **Multiple Runtime Options**
- **useChatRuntime**: Simple integration with Vercel AI SDK endpoints
- **ExternalStoreRuntime**: Full control over state management (recommended for custom backends)
- **LocalRuntime**: Client-side only runtime for testing

### 3. **Customizable Components**
- Message lists with auto-scrolling
- Input fields with keyboard shortcuts
- Thread management (multi-conversation support)
- Custom message rendering (markdown, code blocks, etc.)

### 4. **State Management Flexibility**
- Compatible with Redux, Zustand, TanStack Query
- Custom persistence strategies
- Multi-thread implementations

---

## Architecture for Custom Backend Integration

### Recommended Approach: ExternalStoreRuntime

For this POC with a custom backend agenting framework, we'll use **ExternalStoreRuntime** which provides:

1. **Full State Control**: You own the message state
2. **Custom Backend Integration**: Direct HTTP calls to your backend API
3. **JWT Authentication**: Easy to add auth headers to requests
4. **Streaming Support**: Handle SSE or WebSocket streams from your backend

### High-Level Architecture

```
┌─────────────────────────────────────────────┐
│           React Frontend (Next.js)          │
│  ┌───────────────────────────────────────┐  │
│  │      AssistantRuntimeProvider         │  │
│  │  ┌─────────────────────────────────┐  │  │
│  │  │   ExternalStoreRuntime          │  │  │
│  │  │  - Message State Management     │  │  │
│  │  │  - JWT Token Injection          │  │  │
│  │  │  - Stream Handling              │  │  │
│  │  └─────────────────────────────────┘  │  │
│  │                 ↓↑                     │  │
│  │  ┌─────────────────────────────────┐  │  │
│  │  │    Custom API Client            │  │  │
│  │  │  - HTTP/SSE to Backend          │  │  │
│  │  │  - Token Management             │  │  │
│  │  └─────────────────────────────────┘  │  │
│  └───────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
                      ↓↑
          ┌───────────────────────┐
          │   Backend Framework    │
          │   - Agenting Logic     │
          │   - JWT Validation     │
          │   - Stream Responses   │
          └───────────────────────┘
```

---

## Installation & Setup

### Step 1: Initialize Next.js Project with assistant-ui

```bash
cd frontend
npx assistant-ui@latest create .
```

**Interactive Prompts:**
- Choose: Next.js (App Router)
- TypeScript: Yes
- Choose styling: Tailwind CSS
- Backend: Start with "OpenAI" (we'll customize to our backend)

### Step 2: Install Required Dependencies

```bash
npm install @assistant-ui/react @assistant-ui/react-markdown @assistant-ui/styles
npm install @radix-ui/react-avatar @radix-ui/react-dialog @radix-ui/react-dropdown-menu
npm install @radix-ui/react-popover @radix-ui/react-tooltip @radix-ui/react-slot
npm install ai lucide-react tailwindcss-animate class-variance-authority clsx tailwind-merge
```

### Step 3: Install Additional Dependencies for Custom Backend

```bash
npm install zustand  # For state management
npm install jose     # For JWT handling (optional, if decoding/validating on frontend)
```

---

## Implementation Plan

### Phase 1: Basic Setup (Minimal Running Version)

#### 1.1 Create Project Structure

```
frontend/
├── app/
│   ├── layout.tsx          # Root layout
│   ├── page.tsx            # Main chat page
│   └── api/
│       └── chat/
│           └── route.ts    # Proxy endpoint to backend (with JWT)
├── components/
│   ├── assistant-ui/       # UI components (generated by assistant-ui)
│   └── chat/
│       └── ChatInterface.tsx
├── lib/
│   ├── runtime.ts          # Custom ExternalStoreRuntime setup
│   ├── api-client.ts       # Backend API client with JWT
│   └── store.ts            # State management (Zustand)
├── .env.local              # Environment variables
└── package.json
```

#### 1.2 Environment Configuration

Create `.env.local`:
```bash
NEXT_PUBLIC_BACKEND_URL=http://localhost:8000  # Your backend agenting framework
BACKEND_API_KEY=your-backend-api-key           # If needed
```

#### 1.3 Create API Client with JWT Support

`lib/api-client.ts`:
```typescript
export class BackendApiClient {
  private baseUrl: string;
  private getToken: () => string | null;

  constructor(baseUrl: string, getToken: () => string | null) {
    this.baseUrl = baseUrl;
    this.getToken = getToken;
  }

  async sendMessage(messages: any[]) {
    const token = this.getToken();
    const response = await fetch(`${this.baseUrl}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(token && { 'Authorization': `Bearer ${token}` }),
      },
      body: JSON.stringify({ messages }),
    });

    if (!response.ok) throw new Error('Failed to send message');
    return response;
  }
}
```

#### 1.4 Setup Custom Runtime with ExternalStoreRuntime

`lib/runtime.ts`:
```typescript
import { useExternalStoreRuntime } from "@assistant-ui/react";
import { BackendApiClient } from "./api-client";

export const useCustomRuntime = (apiClient: BackendApiClient) => {
  const [messages, setMessages] = useState([]);

  return useExternalStoreRuntime({
    messages,
    onNew: async ({ message }) => {
      // Add user message to state
      setMessages(prev => [...prev, message]);

      // Send to backend and handle streaming response
      const response = await apiClient.sendMessage([...messages, message]);
      const reader = response.body.getReader();

      // Handle streaming response
      let assistantMessage = { role: 'assistant', content: '' };
      setMessages(prev => [...prev, assistantMessage]);

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        // Parse streaming data and update message
        const chunk = new TextDecoder().decode(value);
        assistantMessage.content += chunk;
        setMessages(prev => [...prev.slice(0, -1), { ...assistantMessage }]);
      }
    },
  });
};
```

#### 1.5 Create Main Chat Component

`components/chat/ChatInterface.tsx`:
```typescript
"use client";

import { AssistantRuntimeProvider, Thread } from "@assistant-ui/react";
import { useCustomRuntime } from "@/lib/runtime";
import { BackendApiClient } from "@/lib/api-client";

export function ChatInterface({ initialToken }: { initialToken?: string }) {
  const [token, setToken] = useState(initialToken);

  const apiClient = new BackendApiClient(
    process.env.NEXT_PUBLIC_BACKEND_URL!,
    () => token
  );

  const runtime = useCustomRuntime(apiClient);

  return (
    <AssistantRuntimeProvider runtime={runtime}>
      <div className="h-screen">
        <Thread />
      </div>
    </AssistantRuntimeProvider>
  );
}
```

#### 1.6 Update Main Page

`app/page.tsx`:
```typescript
import { ChatInterface } from "@/components/chat/ChatInterface";

export default function Home() {
  return <ChatInterface />;
}
```

### Phase 2: JWT Authentication Integration

#### 2.1 Token Management

Options for JWT handling:
1. **Server-side cookies** (recommended for security)
2. **localStorage** (simpler but less secure)
3. **React Context** (for token state management)

Example with cookies:
```typescript
// lib/auth.ts
export function getTokenFromCookie(): string | null {
  if (typeof window === 'undefined') return null;
  const cookies = document.cookie.split(';');
  const tokenCookie = cookies.find(c => c.trim().startsWith('auth_token='));
  return tokenCookie ? tokenCookie.split('=')[1] : null;
}

export function setTokenCookie(token: string) {
  document.cookie = `auth_token=${token}; path=/; secure; samesite=strict`;
}
```

#### 2.2 Protected API Routes

Create Next.js API route that proxies to backend with JWT:

`app/api/chat/route.ts`:
```typescript
import { cookies } from 'next/headers';

export async function POST(req: Request) {
  const cookieStore = cookies();
  const token = cookieStore.get('auth_token')?.value;

  if (!token) {
    return new Response('Unauthorized', { status: 401 });
  }

  const { messages } = await req.json();

  const response = await fetch(`${process.env.BACKEND_URL}/chat`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
    },
    body: JSON.stringify({ messages }),
  });

  // Stream the response back to frontend
  return new Response(response.body, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

### Phase 3: Enhanced Features

#### 3.1 Multi-Thread Support
- Implement thread list component
- Add thread persistence (localStorage or backend)
- Thread switching UI

#### 3.2 Message Customization
- Custom message renderers for agent actions
- Code syntax highlighting
- File attachments
- Image support

#### 3.3 Advanced Agent Features
- Tool call visualization
- Agent thinking/reasoning display
- Progress indicators for long-running tasks
- Error handling and retry logic

---

## Quick Start Commands

### Minimal Setup (Get Running Fast)

```bash
# 1. Navigate to frontend directory
cd frontend

# 2. Initialize project
npx assistant-ui@latest create .

# 3. Install dependencies
npm install

# 4. Set up environment variables
echo "NEXT_PUBLIC_BACKEND_URL=http://localhost:8000" > .env.local

# 5. Start development server
npm run dev
```

The app will be available at `http://localhost:3000`

### Development Workflow

```bash
# Start dev server with hot reload
npm run dev

# Build for production
npm run build

# Start production server
npm start

# Lint code
npm run lint
```

---

## Integration Points with Backend

### Expected Backend API Contract

Your backend agenting framework should expose an endpoint that:

1. **Accepts POST requests** with message array:
```json
{
  "messages": [
    { "role": "user", "content": "Hello" },
    { "role": "assistant", "content": "Hi there!" }
  ]
}
```

2. **Returns streaming responses** (SSE format):
```
data: {"type": "content", "delta": "Hello"}
data: {"type": "content", "delta": " world"}
data: {"type": "done"}
```

3. **Validates JWT tokens** in Authorization header:
```
Authorization: Bearer <your-jwt-token>
```

4. **Handles CORS** for development:
```python
# Example for FastAPI backend
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

---

## Customization Options

### Styling
- Uses Tailwind CSS by default
- Customize theme in `tailwind.config.ts`
- Override component styles in `components/assistant-ui/`

### Components
All assistant-ui components are fully customizable:
- `<Thread />` - Main chat interface
- `<ThreadList />` - Conversation history
- `<Composer />` - Message input
- `<Messages />` - Message list
- Custom message renderers

### Runtime Behavior
- Message preprocessing
- Custom error handling
- Retry logic
- Optimistic updates
- Offline support

---

## Testing Strategy

1. **Unit Tests**: React components with Jest/Vitest
2. **Integration Tests**: API client and runtime logic
3. **E2E Tests**: Playwright for full chat flow
4. **Manual Testing**:
   - JWT token expiration
   - Network interruptions
   - Streaming failures
   - Multi-tab behavior

---

## Security Considerations

### JWT Best Practices
1. **Never store JWT in localStorage** for sensitive apps
2. **Use httpOnly cookies** when possible
3. **Implement token refresh** logic
4. **Add CSRF protection** for cookies
5. **Validate tokens on backend** - never trust frontend

### API Security
1. **Rate limiting** on chat endpoints
2. **Input validation** on backend
3. **Content filtering** for user messages
4. **Audit logging** for compliance

---

## Performance Optimization

1. **Code Splitting**: Lazy load chat components
2. **Message Virtualization**: For long conversations (react-window)
3. **Debounce Typing Indicators**: Reduce unnecessary updates
4. **Memoization**: Use React.memo for message components
5. **Stream Buffering**: Batch small chunks for smoother updates

---

## Troubleshooting

### Common Issues

**Issue**: Messages not streaming
- Check backend CORS settings
- Verify SSE format from backend
- Check browser network tab for errors

**Issue**: JWT not being sent
- Verify cookie settings (domain, secure flag)
- Check cookie expiration
- Ensure httpOnly is set correctly on server

**Issue**: UI not updating
- Check runtime state management
- Verify message format matches expected schema
- Enable React DevTools to inspect component state

---

## Next Steps

### Immediate (Phase 1)
1. Run `npx assistant-ui create` to scaffold project
2. Set up basic API client
3. Implement ExternalStoreRuntime
4. Test with mock backend responses

### Short Term (Phase 2)
1. Integrate JWT authentication
2. Connect to real backend agenting framework
3. Handle streaming responses
4. Add error handling

### Long Term (Phase 3)
1. Multi-thread support
2. Message persistence
3. Advanced agent visualizations
4. Production deployment
5. Analytics and monitoring

---

## Resources

- **Documentation**: https://www.assistant-ui.com/docs
- **GitHub**: https://github.com/assistant-ui/assistant-ui
- **Examples**: https://github.com/assistant-ui/assistant-ui/tree/main/examples
- **Discord**: Join for community support
- **API Reference**: https://www.assistant-ui.com/docs/api

---

## Architecture Decisions

### Why Next.js?
- Server-side rendering for better SEO
- API routes for secure JWT handling
- Built-in optimization and routing
- Great developer experience

### Why ExternalStoreRuntime?
- Full control over state management
- Easy integration with custom backends
- Supports complex authentication flows
- Flexible for future requirements

### Why Not Vercel AI SDK Runtime?
- Requires Vercel AI SDK backend format
- Less control over request/response handling
- Harder to integrate custom authentication
- Our backend is custom, not a standard AI provider

---

## Estimated Timeline

- **Day 1**: Project setup, basic UI running (Phase 1)
- **Day 2-3**: Custom runtime implementation, backend integration (Phase 2)
- **Day 4-5**: JWT authentication, testing (Phase 2 complete)
- **Week 2+**: Enhanced features, production readiness (Phase 3)

---

## Support & Maintenance

- Keep assistant-ui updated: `npm update @assistant-ui/react`
- Monitor GitHub for breaking changes
- Follow semantic versioning for dependencies
- Set up Dependabot for security updates
